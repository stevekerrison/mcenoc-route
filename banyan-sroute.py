#!/usr/bin/env python3
"""
    Banyan Static Router

    Generates headers for a set of static routes of 2-party calls
    in a UoB Banyan-style network of switches. Provided no two sources
    require the same destination, a valid non-blocking route is guaranteed.

Usage:
    banyan-sroute.py -h
    banyan-sroute.py <network.tikz> [<src--dst>...]

Options:
    -h, --help                      Print this help message.

Arguments:
    <network.tikz>                  The network description in Sa-Tikz
                                    butterfly format.
    <src--dst>                      Source and node IDs (up to numports
                                    instances). No repeated srcid or dstid
                                    allowed. Randomly generated by default.

"""

from docopt import docopt
import random
import parse
import math
import networkx as nx
import numpy as np


class BSPMat():

    def __init__(self, srcdst=None):
        if srcdst:
            self.s = {a: {'src': a, 'dst': b, 'os': None, 'od': None} for a, b
                      in srcdst}
            self.d = {b['dst']: b for a, b in self.s.items()}
            self.size = len(self.s)
        else:
            self.s = {}
            self.d = {}

    def insert(self, x):
        newsrc = int(x['src']/2)
        newdst = int(x['dst']/2)
        print ("Inserting ({}, {}) to ({}, {})".format(x['src'], x['dst'],
                                                       newsrc, newdst))
        v = {'src': newsrc, 'dst': newdst, 'os': x['src'], 'od': x['dst']}
        self.s[newsrc] = v
        self.d[newdst] = v

    def delete(self, x):
        newsrc = int(x['src']/2)
        newdst = int(x['dst']/2)
        print ("Deleting ({}, {}) from ({}, {})".format(x['src'], x['dst'],
                                                        newsrc, newdst))
        del self.ps[newsrc][x['src']]
        if len(self.ps[newsrc]) == 0:
            del self.ps[newsrc]
        del self.pd[newdst][x['dst']]
        if len(self.pd[newdst]) == 0:
            del self.pd[newdst]
        return

    def partition(self):
        newsize = int(self.size/2)
        self.ps = {x: {} for x in range(newsize)}
        self.pd = {x: {} for x in range(newsize)}
        self.dbl = {}
        seen = {}
        for x in self.d.values():
            ns = int(x['src']/2)
            nd = int(x['dst']/2)
            self.ps[ns][x['src']] = x
            self.pd[nd][x['dst']] = x
            if (ns, nd) in seen:
                self.dbl[ns, nd] = True
            else:
                seen[ns, nd] = True
        return self

    def permutedbl(self, Pa, Pb):
        """
            Do the permutation splitting for cells that have two entries
        """
        start = 0
        others = self.size - 1
        if len(self.dbl):
            for x in self.dbl:
                v = next(iter(self.pd[x[1]].values()))
                Pa.insert(v)
                self.delete(v)
                v = next(iter(self.pd[x[1]].values()))
                Pb.insert(v)
                self.delete(v)
                others -= 2
            start = next(iter(self.pd))
        return start, others
    
    def newpermute(self, r):
        """
            We hit the end of a cycle without completing the permutation.
            Find a new starting point
        """
        return next(iter(r))
        

    def permutation(self):
        Pa, Pb = BSPMat(), BSPMat()
        startcol, othercols = self.permutedbl(Pa, Pb)
        v = next(iter(self.pd[startcol].values()))
        Pa.insert(v)
        pos = int(v['dst']/2)
        self.delete(v)
        reflu = [self.pd, self.ps]
        refin = [Pb, Pa]
        refdim = ['dst', 'src']
        refidx = 0
        for i in range(othercols):
            refl = reflu[refidx]
            refi = refin[refidx]
            if pos not in refl:
                pos = self.newpermute(refl)
            refidx = (refidx + 1) % 2
            v = next(iter(refl[pos].values()))
            refi.insert(v)
            pos = int(v[refdim[refidx]]/2)
            self.delete(v)
        return Pa, Pb


class BSRoute(nx.DiGraph):
    """
        Static route generator for Banyan-style networks.
    """

    def __init__(self, net, route):
        super(BSRoute, self).__init__()
        netfile = open(net, 'r')
        pr = parse.parse(r"\node[BP={:d}, BN={:d}, BM={:d}, BL={:d}{}",
                         netfile.readline().strip())
        self.nports = pr[0]
        self.nbits = int(math.log(pr[1], 2))
        self.mbits = int(math.log(pr[2], 2))
        self.stages = pr[3]
        self.rbits = self.stages*self.nbits*2 + self.mbits
        self.buildgraph(netfile)
        netfile.close()
        # print (self.nports, self.nbits, self.mbits)
        self.src = []
        self.dst = []
        if len(route) > 0:
            src, dst = [list(l) for l in zip(*[x.split('--') for x in route])]
            self.src = list(map(lambda i: int(i, 0), src))
            self.dst = list(map(lambda i: int(i, 0), dst))
        else:
            self.randroute()
        self.dupecheck(self.src)
        self.dupecheck(self.dst)
        self.rangecheck(self.src)
        self.rangecheck(self.dst)
        return

    def buildgraph(self, netfile):
        cp = parse.compile(
            r"\draw(r{:d}-{:d}-{:w}-{:d})--(r{:d}-{:d}-{:w}-{:d}{}")
        l = netfile.readline().strip()
        while l:
            pr = [x for x in cp.parse(l)][:8]
            fromkey = "L{:d}-S{:d}".format(*map(lambda x: x-1, pr[:2]))
            fromport = pr[3]-1
            tokey = "L{:d}-S{:d}".format(*map(lambda x: x-1, pr[4:6]))
            toport = pr[7]-1
            if pr[2] == 'input':
                fromkey, tokey = tokey, fromkey
                fromport, toport = toport, fromport
            self.add_node(fromkey)
            self.add_node(tokey)
            self.add_edge(fromkey, tokey, {'srcp': fromport, 'dstp': toport})
            l = netfile.readline().strip()
        switch = 0
        port = 0
        nports = 2**self.nbits
        for i in range(self.nports):
            srckey = "N{:d}-src".format(i)
            dstkey = "N{:d}-dst".format(i)
            self.add_node(srckey, {'id': i})
            self.add_node(dstkey, {'id': i})
            swtokey = "L{:d}-S{:d}".format(0, switch)
            swfromkey = "L{:d}-S{:d}".format(self.stages*2, switch)
            self.add_edge(srckey, swtokey, {'dstp': port})
            self.add_edge(swfromkey, dstkey, {'srcp': port})
            port += 1
            if port == nports:
                switch += 1
                port = 0
        return

    def rangeraise(self, v):
        raise ValueError("Value {} outside node range".format(v))

    def rangecheck(self, l):
        if max(l) >= self.nports:
            self.rangeraise(max(l))
        if min(l) < 0:
            self.rangeraise(min(l))

    def dupecheck(self, l):
        seen = set()
        dupes = set(x for x in l if x in seen or seen.add(x))
        if len(dupes) > 0:
            raise ValueError('Duplicate value(s): {}'.format(list(dupes)))
        return

    def randroute(self):
        self.src = random.sample(range(self.nports), self.nports)
        self.dst = random.sample(range(self.nports), self.nports)

    def descendant_endpoints(self, src):
        return set([self.node[x]['id'] for x in nx.descendants(self, src) if
                    x[0] == 'N'])

    def partmat(self, m):
        p1 = m[::2] + m[1::2]
        return p1[:, ::2] + p1[:, 1::2]

    def decomp(self, src, dst):
        print (dst[0])
        pa, pb = {}, {}
        return pa, pb

    def gen(self):
        # self.src = [2, 4, 7, 5, 1, 3, 6, 0]
        # self.src = [7, 3, 5, 1, 6, 2, 0, 4]
        # self.src = [7, 0, 4, 5, 1, 2, 6, 3]
        self.src = [7, 6, 4, 5, 1, 2, 0, 3]
        self.dst = [0, 1, 2, 3, 4, 5, 6, 7]
        Pa = BSPMat(zip(self.src, self.dst))
        print (Pa.d)
        Pa.partition().permutation()
        raise NotImplementedError
        while (Pa.size > 1):
            Pa, Pb = Pa.permutation()
            print (Pa)
            print (Pb)
            raise NotImplementedError
        m = np.zeros([self.nports, self.nports], dtype=int)
        for src, dst in self.routesrc.items():
            m[src][dst] = 1
        # print (m[:, ::2])
        print (m)
        pm = self.partmat(m)
        print (pm)
        pa, pb = self.decomp(pm)
        print (pa)
        print (pb)
        raise NotImplementedError
        self.routeout = {}
        nsw = int(self.nports / 2**self.mbits)
        swk = "L{:d}-S{{:d}}".format(self.stages)
        sw = 0
        target = self.nports
        while len(self.routeout) != target:
            sw = (sw + 1) % nsw
            mid = swk.format(sw)
            routable = self.descendant_endpoints(mid)
            isec = routable.intersection(self.routedst.keys())
            spath = None
            for dst in isec:
                src = self.routedst[dst]
                skey = "N{:d}-src".format(src)
                try:
                    spath = nx.shortest_path(self, skey, mid)
                except nx.exception.NetworkXNoPath:
                    continue
                break
            if spath is None:
                target -= 1
                continue
                raise KeyError(spath, "Invalid path {}".format(spath))
            # print ("Route found from {:d}--{:d}".format(src,dst))
            dkey = "N{:d}-dst".format(dst)
            dpath = nx.shortest_path(self, mid, dkey)
            path = spath + dpath[1:]
            routebits = 0
            for i in range(2, len(path)):
                if i == self.stages:
                    bitshift = self.mbits
                else:
                    bitshift = self.nbits
                routebits <<= bitshift
                routebits |= self.edge[path[i-1]][path[i]]['srcp']
                self.remove_edge(path[i-1], path[i])
            self.routeout[src] = routebits
            # print (src, dst, "{:05b}".format(routebits))
            del self.routesrc[src]
            del self.routedst[dst]
        print ("Routed {:d}/{:d} ({:.2f}%) connections".format(
            len(self.routeout), self.nports,
            float(len(self.routeout))/self.nports * 100))


if __name__ == "__main__":
    ARGS = docopt(__doc__, version="Banyan Static Router v0.0")
    BSR = BSRoute(ARGS['<network.tikz>'], ARGS['<src--dst>'])
    BSR.gen()
