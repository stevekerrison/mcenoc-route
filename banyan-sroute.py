#!/usr/bin/env python3
"""
    Banyan Static Router

    Generates headers for a set of static routes of 2-party calls
    in a UoB Banyan-style network of switches. Provided no two sources
    require the same destination, a valid non-blocking route is guaranteed.

Usage:
    banyan-sroute.py -h
    banyan-sroute.py <network.tikz> [<src--dst>...]

Options:
    -h, --help                      Print this help message.

Arguments:
    <network.tikz>                  The network description in Sa-Tikz
                                    butterfly format.
    <src--dst>                      Source and node IDs (up to numports
                                    instances). No repeated srcid or dstid
                                    allowed. Randomly generated by default.

"""

from docopt import docopt
import random
import parse
import math
import networkx as nx


class BSRoute(nx.DiGraph):
    """
        Static route generator for Banyan-style networks.
    """

    def __init__(self, net, route):
        super(BSRoute, self).__init__()
        netfile = open(net, 'r')
        pr = parse.parse(r"\node[BP={:d}, BN={:d}, BM={:d}, BL={:d}{}",
                         netfile.readline().strip())
        self.nports = pr[0]
        self.nbits = int(math.log2(pr[1]))
        self.mbits = int(math.log2(pr[2]))
        self.stages = pr[3]
        self.rbits = self.stages*self.nbits*2 + self.mbits
        self.buildgraph(netfile)
        netfile.close()
        # print (self.nports, self.nbits, self.mbits)
        self.src = []
        self.dst = []
        if len(route) > 0:
            src, dst = [list(l) for l in zip(*[x.split('--') for x in route])]
            self.src = list(map(lambda i: int(i, 0), src))
            self.dst = list(map(lambda i: int(i, 0), dst))
        else:
            self.randroute()
        self.dupecheck(self.src)
        self.dupecheck(self.dst)
        self.rangecheck(self.src)
        self.rangecheck(self.dst)
        return

    def buildgraph(self, netfile):
        cp = parse.compile(
            r"\draw(r{:d}-{:d}-{:w}-{:d})--(r{:d}-{:d}-{:w}-{:d}{}")
        l = netfile.readline().strip()
        while l:
            pr = [x for x in cp.parse(l)][:8]
            fromkey = "L{:d}-S{:d}".format(*map(lambda x: x-1, pr[:2]))
            fromport = pr[3]-1
            tokey = "L{:d}-S{:d}".format(*map(lambda x: x-1, pr[4:6]))
            toport = pr[7]-1
            if pr[2] == 'input':
                fromkey, tokey = tokey, fromkey
                fromport, toport = toport, fromport
            self.add_node(fromkey)
            self.add_node(tokey)
            self.add_edge(fromkey, tokey, {'srcp': fromport,
                                           'dstp': toport,
                                           'weight': 1,
                                           'usedby': None})
            l = netfile.readline().strip()
        switch = 0
        port = 0
        nports = 2**self.nbits
        for i in range(self.nports):
            srckey = "N{:d}-src".format(i)
            dstkey = "N{:d}-dst".format(i)
            self.add_node(srckey, {'id': i})
            self.add_node(dstkey, {'id': i})
            swtokey = "L{:d}-S{:d}".format(0, switch)
            swfromkey = "L{:d}-S{:d}".format(self.stages*2, switch)
            self.add_edge(srckey, swtokey, {'dstp': port})
            self.add_edge(swfromkey, dstkey, {'srcp': port,
                                              'weight': 1,
                                              'usedby': None})
            port += 1
            if port == nports:
                switch += 1
                port = 0
        return

    def rangeraise(self, v):
        raise ValueError("Value {} outside node range".format(v))

    def rangecheck(self, l):
        if max(l) >= self.nports:
            self.rangeraise(max(l))
        if min(l) < 0:
            self.rangeraise(min(l))

    def dupecheck(self, l):
        seen = set()
        dupes = set(x for x in l if x in seen or seen.add(x))
        if len(dupes) > 0:
            raise ValueError('Duplicate value(s): {}'.format(list(dupes)))
        return

    def randroute(self):
        self.src = random.sample(range(self.nports), self.nports)
        self.dst = random.sample(range(self.nports), self.nports)

    def descendant_endpoints(self, src):
        return set([self.node[x]['id']
                   for x in nx.descendants(self, src) if x[0] == 'N'])

    def erasepath(self, src, path):
        for i in range(2, len(path)):
            e = self.edge[path[i-1]][path[i]]
            e['weight'] -= 1
            if e['usedby'] == src:
                e['usedby'] = None

    def checkroutes(self):
        """
            Goes over a list of paths and ensures validity
        """
        for src, route in self.routeout.items():
            r = route[2]
            for i in range(2, len(r)):
                e = self.edge[r[i-1]][r[i]]
                if e['usedby'] != src:
                    raise ValueError("{}--{} owned by {:d}, not {:d}".format(
                        r[i-1], r[i], e['usedby'], src))

    def erasegraph(self):
        for i in self.edges_iter():
            e = self.edge[i[0]][i[1]]
            if 'weight' in e:
                e['weight'] = 1
            if 'usedby' in e:
                e['usedby'] = None

    def findroute(self, src, dst, replace=False):
        skey = "N{:d}-src".format(src)
        dkey = "N{:d}-dst".format(dst)
        path = random.choice(list(nx.all_shortest_paths(self, skey, dkey,
                                                        weight='weight')))
        if replace:
            self.erasepath(src, self.routeout[src][2])
        routebits = 0
        stolen = []
        for i in range(2, len(path)):
            if i == self.stages:
                bitshift = self.mbits
            else:
                bitshift = self.nbits
            routebits <<= bitshift
            e = self.edge[path[i-1]][path[i]]
            routebits |= e['srcp']
            if e['usedby'] is not None:
                stolen.append(e['usedby'])
            e['weight'] += 1
            e['usedby'] = src
        if len(stolen) > 1:
            self.erasegraph()
            return False
            raise NotImplementedError   # Don't know how to deal with this
        self.routeout[src] = (dst, routebits, path)
        # print (src, dst, "{:05b}".format(routebits), path, stolen)
        for s in stolen:
            if replace:
                self.erasegraph()
                return False
            return self.findroute(s, self.routeout[s][0], True)
        return True

    def gen(self):
        self.route = sorted(zip(self.src, self.dst), key=lambda x: x[0])
        self.routeout = {}
        # nsw = int(self.nports / 2**self.mbits)
        while len(self.routeout) != self.nports:
            for src, dst in self.route:
                result = self.findroute(src, dst)
                if not result:
                    self.routeout = {}
                    print('---')
                    break
        self.checkroutes()

if __name__ == "__main__":
    ARGS = docopt(__doc__, version="Banyan Static Router v0.0")
    BSR = BSRoute(ARGS['<network.tikz>'], ARGS['<src--dst>'])
    BSR.gen()
